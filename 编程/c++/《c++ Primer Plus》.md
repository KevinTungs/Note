# 内容提要

C++是在C语言基础上开发的一种**集面向对象编程、泛型编程和过程化编程于一体的编程语言，是C语言的超集**。本书根据2003年的**ISO/ANSI C++标准**编写

> **ANSI**(American National Standard Institute，美国国家标准协会)
>
> **ISO**(International Standard Organization，国际标准协会)

# 作者介绍

**Stephen Prata（史蒂芬·普拉达）教授**，在美国加州肯特菲尔得的马林学院教授天文、物理和计算机科学

# 前言

**本书在介绍C++特性的同时，讨论了基本C语言，使两者成为有机的整体**。书中介绍了C++的基本概念，并通过短小精悍的程序来阐明，这些程序都很容易复制和试验。书中还介绍了输入和输出，如何让程序执行重复性任务，如何让程序做出选择，处理数据的多种方式，以及如何使用函数等内容。另外，本书还讲述C++在C语言的基础上新增的很多特性，包括：

- 类和对象
- **继承**
- **多态、虚函数和RTTI（运行阶段类型识别）**
- 函数重载
- 引用变量
- **泛型（独立于类型的）编程**（这种技术是由模板和标准模板库（STL）提供的）
- **处理错误条件的异常机制**
- **管理函数、类和变量名的名称空间**

## 初级教程方法

初级教程提供问题和练习来检验您对知识的理解，从而适于自学或课堂教学

**本书的目标是，您阅读本书后，能够编写出可靠、高效的程序，并且觉得这是一种享受**

## 示例代码

本书中包含大量示例代码，其中大部分是完成的程序。**本书介绍的是通用C++，因此适用于任何计算机、操作系统和编译器**。书中的示例在Windows7系统、Macintosh OS X系统和Linux系统上进行了测试

> **Macintosh OS X** mac系统的一个版本

## 本书内容

### 第1章 预备知识

1. **Bjarne Stroustrup（本贾尼·斯特劳斯特卢普）**如何通过在C语言的基础上添加对面向对象编程的支持，在创造C++编程语言
2. 讨论**面向过程语言（如C语言）与面向对象语言（如C++）**之间的区别
3. ANSI/ISO在制定C++标准方面所做的工作
4. 创建C++程序的技巧，介绍了当前几种C++编译器使用的方法
5. 介绍了本书的一些约定

### 第2章 开始学习C++

1. 创建简单C++程序的步骤
2. **main()函数扮演的角色**和C++程序使用的一些语句
3. 使用预定义的cout和cin对象实现程序输出和输入
4. 如何创建和使用变量
5. **函数——C++的编程模块**

### 第3章 处理数据

1. C++提供了内置类型储存整数和浮点数
2. C++为每一种数据都提供了几个类型，本章将要讨论这些类型，包括创建变量和编写各种类型的变量
3. **C++是如何处理不同类型之间的隐式和显式转换的**

### 第4章 复合类型

1. C++让程序员能够使用基本的内置类型来创建更复杂的类型。**最高级的形式是类**
2. 数组（储存多个同类型的值）、结构（存储多个不同类型的值）、指针（标识内存位置）
2. 如何创建和储存文本字符串及如何使用C-风格字符数组和C++ string类来处理文本输入和输出
2. **学习C++处理内存分配的一些方法，包括用于显示地管理内存的new和delete运算符**

### 第5章 循环和关系表达式

1. for循环、while循环和do while循环，这些循环必须知道何时终止，C++的关系运算符使程序员能够创建测试来引导循环
2. 如何创建逐字符地读取和处理输入的循环
3. 如何创建二维数组以及如何使用嵌套循环来处理它们

### 第6章 分支语句和逻辑运算符

1. 如何使用if、if else和switch语句及条件运算符来控制程序流程
2. 如何使用逻辑运算符来表达决策测试
3. **介绍确认字符关系（如测试字符是数字还是非打印字符）的函数库cctype**
4. 简要地介绍文件输入/输出

### 第7章 函数——C++的编程模块

1. **函数是C++的基本编程部件**
2. 本章重点介绍C++函数与C函数的共同特性
3. 复习函数定义的通用格式
4. 了解**函数原型是如何提高程序可靠性的**
5. 如何编写函数来处理数组、字符串和结构
6. 学习有关递归的知识（即函数在什么情况下调用自身）以及如何用它来实现分而治之的策略
7. 介绍**函数指针**（使程序员通过函数参数来命令函数使用另一个函数）

### 第8章 函数探幽

1. **本章将探索C++中函数新增的特性，类设计中经常使用这些特性**
2. 学习**内联函数**（可以提高程序的执行速度，但会增加程序的长度）
3. 引用变量（提供了另一种将信息传递给函数的方式）
4. 默认参数（使函数能够自动为函数调用中省略的函数参数提供值）
5. 函数重载（使程序员能够创建多个参数列表不同的同名函数）
6. **函数模板（使程序员能够指定相关函数族的设计）**

### 第9章 内存模型和名称空间

1. 本章将讨论如何创建多文件程序
2. 介绍**分配内存的各种方式和管理内存的各种方式**
3. **介绍作用域、链接、名称空间**
4. **这些内容决定了变量在程序的哪些部分是可见的**

### 第10章 对象和类

1. **类是用户定义的类型**
2. **对象（如变量）是类的实例**
3. 本章介绍面向对象编程和类设计
4. **对象声明描述的是存储在对象中的信息以及可对对象执行的操作（类方法）**
5. 对象的某些组成部分对于外界来说是可见的（公有部分），而某些部分却是隐藏的（私有部分）
6. 特殊的类方法（构造函数和析构函数）在对象创建和释放时发挥作用
7. **了解如何使用类来实现ADT，如栈**

> 抽象数据类型（Abstract Data Type，ADT）是计算机科学中**具有类似行为的特定类别的数据结构的数学模型；或者具有类似语义的一种或多种程序设计语言的数据类型**。**抽象数据类型是间接定义的，通过其上的可执行的操作以及这些操作的效果的数学约束（与可能的代价）**

### 第11章 使用类

1. 在本章中，您将深入了解类
2. **了解运算符重载**（使得程序员能够定义与类对象一起使用的运算符，如+）
3. **学习友元函数**（这些函数可以访问外部世界不可访问的类数据）
4. **了解一些构造函数和重载运算符成员函数是如何被用来管理类类型转换的**

### 第12章 类和动态内存分配

1. 一般来说，**让类成员指向动态分配的内存很有用**（如果程序员在类构造函数中使用new来分配动态内存，就有责任提供适当的析构函数，定义显式拷贝构造函数和显式赋值运算符）
2. 本章介绍了在程序员没有提供显式定义时，将如何隐式地生成成员函数以及这些成员函数的行为
3. 通过使用**对象指针**，了解队列模拟问题，扩充类方面的知识

### 第13章 类继承

1. 在面向对象编程中，**继承是功能最强大的特性之一**（通过继承，派生类可以继承基类的特性，可重用基类代码）
2. 本章讨论**公有继承**，这种继承模拟了is-a关系（即派生对象是基对象的特例）
3. **有些继承关系是多态的**（意味着相同的方法名称可能导致依赖于对象类型的行为）
4. 要实现这种行为需要使用一种新的成员函数——**虚函数**
5. **有时使用抽象基类是实现继承关系的最佳方式**
6. 本章讨论了这些问题，说明了公有继承在什么情况下合适，在什么情况下不合适

### 第14章 C++中的代码重用

1. 公有继承只是代码重用的方法之一，本章将介绍其他几种方式
2. **包含**（一个类包含另一个类的对象）可以模拟has-a关系
3. 使用**私有继承和保护继承**来模拟这种关系
4. 说明了各种方法之间的区别
5. 学习**类模板**（使程序员能够使用泛型来定义类，然后使用模板根据具体类型创建特定的类）
6. 介绍**多重公有继承**（使用这种方式，一个类可以从多个类派生而来）

### 第15章 友元、异常和其他

1. 本章扩展了对友元的讨论，讨论了**友元类和友元成员函数**
2. 从**异常**开始介绍了C++的几项新特性（异常为处理程序异常提供了一种机制）
3. 学习**RTTI**，这种机制用来确定对象类型

> **RTTI**（Run-Time Type Identification)，通过运行时类型信息程序能够使用基类的指针或引用来检查这些指针或引用所指的对象的实际派生类型

4. 介绍**一种更安全的方法来替代不受限制的强制类型转换**

### 第16章 string类和标准模板库

1. 本章讨论C++语言中新增的一些类库
2. 对于传统的C-风格字符串来说，string是一种方便且功能强大的替代方式
3. **auto_ptr类**帮助管理动态分配的内存
4. **STL**提供了几种类容器（包括数组、队列、链表、集合和映射）的模板表示，还提供了高效的泛型算法库，这些算法可用于STL容器，也可用于常规数组
5. **模板类valarray**为数值数组提供了支持

### 第17章 输入、输出和文件

1. 本章复习C++ I/O，并讨论如何格式化输出
2. 学习如何使用**类方法**来确定输入或输出流的状态
3. 了解输入类型是否匹配或者是否检测到了文件尾

> C++使用**继承**来派生用于管理文件输入和输出的类

4. 学习如何打开文件以进行输入和输出
5. 如何在文件中追加数据
6. 如何使用二进制文件
7. 如何获得对文件的**随机访问权**
8. 如何使用**标准的I/O方法**来读取和写入字符串

### 第18章 探讨C++新标准

1. 本章复习之前介绍过的几项C++11新功能，包括**新类型、统一的初始化语法、自动类型判断、新的智能指针以及作用域内枚举**
1. 讨论新增的**右值引用类型**以及如何使用它来实现移动语义
1. 介绍新增的**类功能、lambda表达式和可变参数模板**
1. 概述众多其他的新功能

### 附录A

计数系统

### 附录B

C++保留字

### 附录C

ASCII字符集

### 附录D

运算符优先级

### 附录E

其他运算符

### 附录F

模板类string

### 附录G

标准模板库方法和函数

### 附录H

精选读物和网上资源

### 附录I

转换ISO标准C++

### 附录J

复习题答案

## 本书约定

### 旁注

提供更深入的讨论和额外的背景知识，帮助阐明主题

### 提示

提供特定编程情形下很有帮助的简单指南

### 警告

提出潜在的陷阱

### 注意

提供不属于其他类型的各种说明

# 第1章 预备知识

C++在C语言的基础上添加了对**面向对象编程**和**泛型编程**的支持，基础了C语言**高效、简洁、快速和可移植性**的传统

> 面向对象的特性带来了全新的编程方法，这种方法是为了**应付复杂程度不断提高的现代编程任务**而设计的

## 1.1 C++简介

C++融合了3种不同的编程方式：

1. C语言代表的**过程性语言**
2. C++在C语言基础上添加的类代表的**面向对象语言**
3. C++模板支持的**泛型编程**

使用C++的原因之一是为了利用其面向对象的特性。要利用这种特性，必须对标准C语言知识有较深入的了解，因为它提供了基本类型、运算符、控制结构和语法规则。**从C过度到C++的学习量就和从头学习C语言一样大，而且必须摒弃一些编程习惯**。如果不了解C语言，则学习C++时需要掌握**C语言的知识、OOP知识以及泛型编程知识**

## 1.2 C++简史

体积更大、功能更强的计算机引出了更大、更复杂的程序，而这些程序在程序管理和维护方面带来了新的问题。20世纪70年代，**C和Pascal**这样的语言引领人们进入了**结构化编程时代**。

> **Pascal（结构化编程语言）:**
>
> Pascal的名称是为了纪念十七世纪法国著名哲学家和数学家Blaise Pascal而来的，它由瑞士Niklaus Wirth教授于六十年代末设计并创立的。Pascal语言语法严谨，层次分明，程序易写，可读性强，是第一个结构化编程语言。Pascal语言广泛用于各种软件，程序分为名称（program后自拟）、设置（var后规定）、开始（begin)、程序（正文）、读取（read/read ln）、结束（end），结构层次强，严谨而又紧密。

C还能生成**简洁、快速运行**的程序，并提供了**处理硬件问题的能力**（如管理通信端口和磁盘驱动器）。这些因素使C语言成为20世纪80年代占统治地位的编程语言。同时20世纪80年代人们也见证了一种新编程模式的成长：**面向对象编程（OPP）**，**SmallTalk和C++语言**具备这种功能

> **Smalltalk：**
>
> 被公认为历史上**第二个面向对象的程序设计语言**，和**第一个真正的集成开发环境**（IDE）。Smalltalk由艾伦·凯，Dan Ingalls，Ted Kaehler，Adele Goldberg等于70年代初在Xerox PARC开发。 Smalltalk对其它众多的程序设计语言的产生起到了极大的推动作用，主要有：C++，C#，Objective-C，Actor，Java和Ruby等。90年代的许多软件开发思想得利于Smalltalk，例如设计模式、敏捷编程和代码重构等。

### 1.2.1 C语言

20世纪70年代早期，**贝尔实验室的Dennis Ritchie**致力于开发**UNIX操作系统**，他需要一种能够**生成简洁、快速的程序，并且能有效地控制硬件的语言**

> **美国贝尔实验室：**
>
> **晶体管**、激光器、太阳能电池、发光二极管、数字交换机、通信卫星、电子数字计算机、**C语言**、**UNIX操作系统**、蜂窝移动通信设备、长途电视传送、仿真语言、有声电影、立体声录音，以及**通信网**等许多重大发明的诞生地
>
> 自1925年以来，贝尔实验室共获得两万五千多项专利，现在，平均每个工作日获得三项多专利。贝尔实验室的使命是为客户创造、生产和提供富有创新性的技术，这些技术使朗讯科技（Lucent Technologies）公司在通信系统、产品、元件和网络软件方面处于全球领先地位。一共获得8项（13人）诺贝尔奖（其中7项物理学奖，1项化学奖）
>
> **丹尼斯·里奇（Dennis Ritchie）：**
>
> 1941年9月9日-2011年10月12日，C语言之父，UNIX之父。曾担任朗讯科技公司贝尔实验室下属的计算机科学研究中心系统软件研究部的主任一职。1978年与布莱恩·科尔尼干（Brian W. Kernighan）一起出版了名著《C程序设计语言（The C Programming Language）》。此书已翻译成多种语言，被誉为c语言的圣经。2011年10月12日（北京时间为10月13日），丹尼斯·里奇去世，享年70岁。
>
> **操作系统：**
>
> 能够管理计算机资源、处理计算机与用户之间交互的一组程序

传统上，程序员使用**汇编语言**来满足这些需求。汇编语言依赖于计算机的内部机器语言，是**低级（low-level）语言，即直接操纵硬件**。因此汇编语言针对特定的计算机处理器，要将汇编程序移植到另一种计算机上，必须使用不同的汇编语言重新编写

UNIX是为在不同的计算机（或平台）上工作而设计的，这意味着它是一种高级语言。**高级（high-level）语言致力于解决问题，而不针对特定的硬件**。一种被称为**编译器**的特殊程序将高级语言翻译成特定的计算机的内部语言，这样就可以通过**对每个平台使用不同的编译器**来在不同的平台上使用同一个高级语言程序了

Ritchie希望有一种语言能将**低级语言的效率、硬件访问能力和高级语言的通用性、可移植性融合在一起**，于是他在旧语言的基础上开发了C语言

### 1.2.2 C语言编译原理

计算机语言要处理两个概念——**数据和算法**。数据是程序使用和处理的信息，而算法是程序使用的方法（见图1.1）

![image-20220126055009847](%E5%9B%BE%E7%89%87/image-20220126055009847.png)

C语言与当前最主流的语言一样，最初也是**过程性（procedural）语言**，这意味着它强调的是编程的算法方面。从概念上说，过程化编程**首先要确定计算机应采取的操作**，然后使用编程语言来实现这些操作。**程序命令计算机按一系列流程生成特定的结果**

#### 结构化编程

随着程序规模的扩大，早期的程序语言（如FORTRAN和BASIC）都会遇到组织方面的问题，很多旧式程序的执行路径很混乱（被称为“意大利面条式编程”），**几乎不可能通过阅读程序来理解它**，修改这种程序简直是一场灾难。为了解决这种问题，一种**更有序**的编程方法——**结构化编程（structured programming）**被开发出来

> **FORTRAN语言**是Formula Translation的缩写，意为“公式翻译”。它是为科学、工程问题或企事业管理中的那些能够用数学公式表达的问题而设计的，其数值计算的功能较强。 FORTRAN语言是世界上第一个被正式推广使用的高级语言。它是1954年被提出来的，1956年开始正式使用，直到2022年已有六十六年的历史，但仍历久不衰，它始终是数值计算领域所使用的主要语言
>
> **BASIC**（Beginners' All-purpose Symbolic Instruction Code，又译培基），意思就是“初学者通用符号指令代码”，是一种设计给初学者使用的程序设计语言。BASIC是一种**直译式的编程语言**，在完成编写后不须经由编译及连结等手续即可执行，但如果需要单独执行时仍然需要将其建立成执行档。 BASIC是由达特茅斯学院院长、匈牙利人约翰·凯梅尼（John G. Kemeny）与数学系教师托马斯·卡茨（Thomas E. Kurtz）共同研制出来的。1964年BASIC语言正式发布。第一个BASIC程序在1964年5月1日早上4时，由BASIC编译程序进行编译后成功运行。1975年，比尔·盖茨把它移植到PC上

**C语言具有结构化编程的特性**，C语言的词汇表中就包含了这些结构（for循环、while循环、do while循环和if else语句）

#### 自顶而下

另一个新原则是**自顶而下（top-down）**的设计。在C语言中，其**理念是将大型程序分解成小型、便于管理的任务**。这一过程将一直持续下去，直到将程序划分为小型的、易于编写的模块。C语言鼓励程序员**开发程序单元（函数）来表示各个任务模块**

**结构化编程技术反映了过程性编程的思想，根据执行的操作来构思一个程序**

### 1.2.3 面向对象编程

 虽然结构化编程的理念提高了程序的清晰度、可靠性，并使之便于维护，但它在编写大型程序时，仍面临着挑战。OOP提供了一种新方法，**与强调算法的过程性编程不同的是，OOP强调的是数据**。过程性编程是试图使问题满足语言的过程性方法，而OOP试图让语言满足问题的要求。其理念是设计与问题的本质特性相对应的数据格式

在C++中，类是一种规范，它描述了这种新型数据格式，**对象是根据这种规范构造的特定数据结构**。通常，类规定了可使用哪些数据来表示对象以及可以对这些数据执行哪些操作

**OOP程序设计方法首先设计类，他们准确地表示了程序要处理的东西，类定义描述了对每个类可执行的操作**。从低级组织（如类）到高级组织（如程序）的处理过程叫做**自下向上（bottom-up）的编程**

#### 意义

OOP编程并不仅仅是将数据和方法合并为类定义，它还可以：

1. 有助于**创建可重用的代码**，减少大量的工作
2. **信息隐藏**可以保护数据，使其免遭不适当的访问
3. **多态**可以为运算符和函数创建多个定义，通过编程上下文来确定使用哪个定义
4. **继承**可以使用旧类派生出新类

OOP引入了很多新的理念，使用的编程方法不同于过程性编程。**它不是将终点放在任务上，而是放在表示概念上**。**有时不一定使用自上而下的编程方法，而是使用自下而上的编程方法**

OOP语言使程序员在编程中能够轻松地使用已有的类。厂商提供了大量有用的类库，包括设计用于简化Windows或Macintosh环境下编程的类库

**C++真正的优点之一是：可以方便地重用和修改现有的、经过仔细测试的代码**

### 1.2.4 C++和泛型编程

**泛型编程（generic programming）**是C++支持的另一种编程模式。它与OOP的目标相同，即使重用代码和抽象通用概念的技术更简单。**OOP强调的是编程的数据方面，而泛型编程强调的是独立于特定数据类型**

OOP是一个管理大型项目的工具，而**泛型编程提供了执行常见任务的工具**

**术语泛型（generic）**指的是创建独立于类型的代码。泛型编程需要对语言进行扩展，以便可以只编写一个泛型（即不是特定类型的）函数，并将其用于各种实际类型。C++模板提供了完成这种任务的机制

### 1.2.5 C++的起源

C++和C一样，也是在贝尔实验室诞生的，**Bjarne Stroustrup**于20世纪80年代开发出了这种语言

> **本贾尼·斯特劳斯特卢普**（Bjarne Stroustrup，1950年6月11日-），丹麦人，计算机科学家，在德克萨斯A&M大学担任计算机科学的主席教授。他最著名的贡献就是开发了C++程序设计语言。1982年，美国AT&T公司贝尔实验室的本贾尼博士在C语言的基础上引入并扩充了面向对象的概念，发明了—种新的程序语言。为了表达该语言与C语言的渊源关系，它被命名为C++。而本贾尼博士被尊称为**C++语言之父。**

Stroustrup比较关心的是让C++更有用，而不是实施特定的编程原理或风格。在确定C++语言特性方面，**真正的编程需要比纯粹的原理更重要**

Stroustrup加入了OOP特性和对C的泛型编程支持，但并没有对C的组件作很大的改动。因此，**C++是C语言的超集**，任何有效的C程序都是有效的C++程序。**名称C++来自C语言中的递增运算符++。名称C++表明它是C的扩充版本**

**OOP部分赋予了C++语言将问题所涉及的概念联系起来的能力，C部分则赋予了C++语言紧密联系硬件的能力**（见图1.2），这种能力上的结合成就了C++的广泛传播

![image-20220126065432265](%E5%9B%BE%E7%89%87/image-20220126065432265.png)

在C++获得一定程度的成功后，Stroustrup才添加了模板，这使得进行泛型编程成为可能。在模板特性被使用和改进后，人们才逐渐认识到，它们和OOP同样重要——**甚至比OOP还重要**

C++融合了OOP、泛型编程和传统的过程性方法，这表明**C++强调的是实用价值，而不是意识形态方法**，这也是该语言获得成功的原因之一

## 1.3 可移植性和标准

#### 可移植性

如果同一个程序在**不修改代码**的情况下，**重新编译程序后**在**不同的操作系统和处理器上都运行良好**，则称该程序是**可移植**的

可移植性方面存在两个障碍：

1. **硬件特定的程序是不可移植的**
2. 语言上的差异

针对第一个问题，将依赖于硬件的部分放在函数模块中可以最大限度地降低可移植性的问题，这样只要重新编写这些模块即可

而第二个问题则需要制定相关的语言标准

#### 标准

美国国家标准局（American National Standards Institute，ANSI）在1990年设立了一个委员会（ANSI X3J16），专门负责制定C++标准（**ANSI制定了C语言标准**）。国际化标准组织（ISO）很快通过自己的委员会（ISO-WG-21）加入了这个行列，**创建了联合组织ANSI/ISO，致力于制定C++标准**

##### C++98

经过多年努力，制定出了一个国际标准：ISO/IEC 14882:1998，并与1998年获得了ISO、IEC（International Electrotechnical Committee，国际电工技术委员会）和ANSI的批准。该标准常被称为**C++98**

该标准描述了已有的C++特性，还对该语言进行了扩展，**添加了异常、运行阶段类型识别（RTTI）、模板和标准模板库（STL）**

##### C++03

2003年，发布了C++标准第二版（IOS/IEC 14882:2003）。这个新版本是一次技术性修订，对第一版进行了整理——修订错误、减少多义性等，但没有改变语言特性。这个版本常被称为C++03。**由于没有改变语言特性，所以我们使用C++98表示C++98/C++2003**

##### C++11

ISO标准委员会在2011年8月批准了新标准ISO/IEC 14882:2011，该标准以前被称为C++11。它新增了众多特性，其目标是消除不一致性，让C++学习和使用起来更容易

> 该标准曾被称为C++0x，最初预期x为7或8，但标准制定是一个令人疲惫的缓慢过程，不过0x可以视为十六进制数，这意味着委员会只需在2015年完成任务即可

##### C++14

在C++11中，lambda函数参数需要被声明为具体的类型。C++14放宽了这一要求，允许lambda函数参数类型使用类型说明符auto

C++11允许lambda函数根据return语句的表达式类型推断返回类型。C++14为所有的函数提供了这个能力。C++14还拓展了原有的规则，使得函数体并不是return expression;形式的函数也可以使用返回类型推导

##### C++17

主要新特性如下：

- 构造函数模板推导
- 结构化绑定
- if-switch语句初始化
- 内联变量
- 折叠表达式
- constexpr lambda表达式
- namespace嵌套
- __has_include预处理表达式
- 在lambda表达式用*this捕获对象副本
- 新增Attribute
- 字符串转换

#### C标准与C++

**ISO C++标准还吸收了ANSI C语言标准**，因为C++应尽量是C语言的超集。ANSI C与对应的C++规则之间存在一些差别，但这些差别很小

在ANSI C出现之前，C语言社区遵循一种事实标准，该标准基于Kernighan和Ritchie编写的《The C Programming Language》一书，通常被称为K&R C。**ANSI C出现后，更简单的K&R C有时被称为经典C（Classic C）**

ANSI C标准不仅定义了C语言，还定义了一个ANSI C实现必须支持的标准C库。C++也使用了这个库，本书将其成为**标准C库**或者**标准库**。另外，ANSI/ISO C++标准还提供了一个C++标准类库

### 1.3.1 C++的发展

Stroustrup编写的**《The Programming Language》**包含65页参考手册，**它成了最初的C++事实标准**

下一个事实标准是Ellis和Stroustrup编写的《The Annotated C++ Reference Manual》

C++98标准新增了大量特性，其篇幅将近800页，且包含的说明很少

C++11标准的篇幅长达1350页，对旧标准做了大量的补充

### 1.3.2 本书遵循的C++标准

本书详尽地介绍了C++98，并涵盖了C++11新增的一些特性

## 1.4 程序创建的技巧

编程完成C++程序后，让其运行起来的步骤大致如下：

1. 使用文本编辑器编写程序，并将其保存到文件中，这个文件就是程序的**源代码**
2. 编译源代码。这意味着运行一个程序，将源代码翻译为主机使用的内部语言——**机器语言**。**包含了翻译后的程序的文件就是程序的目标代码（object code）**
3. **将目标代码与其他代码链接起来**。C++程序通常使用库，**C++库**包含一系列计算机例程（被称为函数）的目标代码。**链接**指的是将目标代码**同使用的函数的目标代码**以及一些**标准的启动代码（startup code）**组合起来，生成程序的运行阶段版本。包含该最终产品的文件被称为**可执行代码**

![image-20220131002919859](%E5%9B%BE%E7%89%87/image-20220131002919859.png)

### 1.4.1 创建源代码文件

本书余下的篇幅讨论源代码文件中的内容：本节讨论创建源代码文件的技巧

#### C++实现

有些C++实现（如 Microsoft Visual C++）提供了**集成开发环境**（integrated development environment，IDE），让程序员可以**在主程序中管理程序开发的所有步骤，包括编辑**

有些实现（如用于UNIX和Linux的GNU C++）**只能处理编译和链接阶段**，要求**在系统命令行输入命令**。在这种情况下，可以使用任何文本编辑器来创建和修改源代码

#### 源文件后缀

给源文件命名时必须使用正确的**后缀**，将文件标识为C++文件。这不仅可以告诉程序员该文件为C++源代码，还将这个信息告知编译器（如果UNIX编译器显示信息“bad magic number”则说明后缀不正确）。**后缀由一个句点和若干个字符组成，这些字符被称作扩展名**（参见图1.4）

![image-20220131003230479](%E5%9B%BE%E7%89%87/image-20220131003230479.png)

**使用什么扩展名取决于C++实现**，表1.1列出了一些常用的扩展名

**UNIX区分大小写**，这意味着小写的c表示C程序，而大写的C表示C++程序（实际上小写c扩展名也有效）。对于某些UNIX系统，也可以使用拓展名cc和cxx。**DOS比UNIX稍微简单一点，不区分大小写，因此DOS实现使用额外的字母来区别C和C++程序**

![image-20220131004433875](%E5%9B%BE%E7%89%87/image-20220131004433875.png)

### 1.4.2 编译和链接

最初，Stroustrup实现C++时，**使用了一个C++到C的编译器程序**，而不是开发直接的C++到目标代码的编译器。前者**叫做cfront**（表示C前端，C front end），**它将C++源代码翻译成C源代码**，然后使用一个标准C编译器对其进行编译

> cfront简化了向C的领域引入C++的过程，其他实现也采用这种方法将C++引入到其他平台

随着C++的日渐普及，越来越多的实现转向创建**C++编译器，直接将C++源代码生成目标代码**，这种直接方法**加速了编译过程，并强调C++是一种独立的语言**

编译的机理取决于实现，接下来的几节将介绍一些常见的形式。这些总结概括了基本步骤，但**对于具体步骤，必须查看系统文档**

#### UNIX编译和链接

最初，UNIX命令CC调用**cfront**，但cfront未能紧跟C++的发展步伐，**其最后一个版本发布于1993年**。如果UNIX计算机上有C++编译器，**很多情况下命令CC仍然管用**。出于简化的目的，**读者应假设命令CC可用**，但必须认识到这一点，即**对于下述讨论中的CC，可能必须使用其他命令来代替**

**使用CC命令来编译程序，名称采用大写字母**，这样可以将它与标准UNIX C编译器cc区分开来。CC编译器是命令行编译器，这意味着需要在UNIX命令行上输入编译命令

例如，要编译C++源码文件spiffy.C，则应在UNIX提示符下输入如下命令：

~~~UNIX
CC spiffy.C
~~~

**如果由于技巧、努力或是幸运的因素，程序没有错误**，则编译器会生成一个拓展名为o的**目标代码**文件，在该例子中，为spiffy.o

接下来，编译器**自动将目标代码文件传递给系统链接程序**，该程序将代码与库代码结合起来，生成一个可执行文件，在默认情况下，可执行程序为a.out

> 如果只使用一个源文件，链接程序还将删除spiffy.o文件，因为这个文件不再需要了

**要运行该程序，只需输入可执行文件的文件名即可：**

~~~UNIX
a.out
~~~

> **如果编译新程序，新的可执行文件a.out将覆盖已有的a.out**。如果想要保留可执行文件，只需使用UNIX的**mv命令**来**修改可执行文件的文件名**即可

在 C++中，程序也可以包含多个文件，可以通过在命令行上列出全部文件来编译程序：

~~~UNIX
CC my.C precious.C
~~~

**在这种情况下，编译器不会删除目标代码文件**。这样，如果**只修改了my.C文件**，则可用下面的命令重新编译该程序：

~~~UNIX
CC my.C precious.o
~~~

**这将重新编译my.C文件，并将它与前面编译的precious.o文件链接起来**

> 有时可能需要显示地制定一些库。例如要访问数学库中定义的函数，必须在命令行中加上-lm标记：
>
> ~~~UNIX
> CC usingmath.C -lm
> ~~~

#### Linux编译和链接

**Linux系统中最常用的编译器是g++**，这是来自**Free Software Foundation**的GNU C++编译器

> **自由软件基金会（Free Software Foundation，FSF）**是一个致力于推广自由软件、促进计算机用户自由的美国民间非盈利性组织。它于1985年10月由理查德·斯托曼建立。其主要工作是执行GNU计划，开发更多的自由软件，完善自由软件理念
>
> > **GNU计划**，有译为“革奴计划”，是由理查德·斯托曼在1983年9月27日公开发起的自由软件集体协作计划。它的目标是创建一套完全自由的操作系统GNU

g++编译器的工作方式很像标准UNIX编译器。例如，下面的命令将生成可执行文件a.out

~~~Linux
g++ spiffy.cxx
~~~

> 有些版本可能要求链接C++库
>
> ~~~Linux
> g++ spiffy.cxx -lg++
> ~~~

要编译多个源文件，只需将它们全部放到命令行中即可：

~~~Linux
g++ my.cxx precious.cxx
~~~

**这将生成一个名为a.out的可执行文件和两个目标代码文件my.o和precious.o**，如果接下来修改了其中的某个源代码文件，如my.cxx，则可用my.cxx和precious.o来重新编译：

~~~Linux
g++ my.cxx precious.o
~~~

> **GNU编译器可以在很多平台上使用**，包括基于Windows的PC和在各种平台上运行的UNIX系统

#### Windows命令行编译器

要在Windows PC上编译C++程序，最便宜的方法是下载一个在Windows命令提示符模式下运行的免费命令行编译器。Cygwin和MinGW都包含编译器GNU C++，且可以免费下载，它们使用的编译器名为g++

